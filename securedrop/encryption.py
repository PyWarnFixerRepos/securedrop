import os
import re
import typing
from datetime import date
from distutils.version import StrictVersion
from pathlib import Path
from typing import Optional

import pretty_bad_protocol as gnupg
from redis import Redis
from sdconfig import SecureDropConfig

import redwood

if typing.TYPE_CHECKING:
    from models import Source
    from source_user import SourceUser


def _monkey_patch_username_in_env() -> None:
    # To fix https://github.com/freedomofpress/securedrop/issues/78
    os.environ["USERNAME"] = "www-data"


def _monkey_patch_unknown_status_message() -> None:
    # To fix https://github.com/isislovecruft/python-gnupg/issues/250 with Focal gnupg
    gnupg._parsers.Verify.TRUST_LEVELS["DECRYPTION_COMPLIANCE_MODE"] = 23


def _monkey_patch_delete_handle_status() -> None:
    # To fix https://github.com/freedomofpress/securedrop/issues/4294
    def _updated_handle_status(self: gnupg._parsers.DeleteResult, key: str, value: str) -> None:
        """
        Parse a status code from the attached GnuPG process.
        :raises: :exc:`~exceptions.ValueError` if the status message is unknown.
        """
        if key in ("DELETE_PROBLEM", "KEY_CONSIDERED"):
            self.status = self.problem_reason.get(value, "Unknown error: %r" % value)
        elif key in ("PINENTRY_LAUNCHED"):
            self.status = key.replace("_", " ").lower()
        else:
            raise ValueError("Unknown status message: %r" % key)

    gnupg._parsers.DeleteResult._handle_status = _updated_handle_status


def _setup_monkey_patches_for_gnupg() -> None:
    _monkey_patch_username_in_env()
    _monkey_patch_unknown_status_message()
    _monkey_patch_delete_handle_status()


_setup_monkey_patches_for_gnupg()


_default_encryption_mgr: Optional["EncryptionManager"] = None


class EncryptionManager:

    GPG_KEY_TYPE = "RSA"
    GPG_KEY_LENGTH = 4096

    # All reply keypairs will be "created" on the same day SecureDrop (then
    # Strongbox) was publicly released for the first time.
    # https://www.newyorker.com/news/news-desk/strongbox-and-aaron-swartz
    DEFAULT_KEY_CREATION_DATE = date(2013, 5, 14)

    # '0' is the magic value that tells GPG's batch key generation not
    # to set an expiration date.
    DEFAULT_KEY_EXPIRATION_DATE = "0"

    SOURCE_KEY_NAME = "Source Key"
    SOURCE_KEY_UID_RE = re.compile(r"(Source|Autogenerated) Key <[-A-Za-z0-9+/=_]+>")

    def __init__(self, gpg_key_dir: Path) -> None:
        self._gpg_key_dir = gpg_key_dir

        # Instantiate the "main" GPG binary
        gpg = gnupg.GPG(
            binary="gpg2", homedir=str(self._gpg_key_dir), options=["--trust-model direct"]
        )
        if StrictVersion(gpg.binary_version) >= StrictVersion("2.1"):
            # --pinentry-mode, required for SecureDrop on GPG 2.1.x+, was added in GPG 2.1.
            self._gpg = gnupg.GPG(
                binary="gpg2",
                homedir=str(gpg_key_dir),
                options=["--pinentry-mode loopback", "--trust-model direct"],
            )
        else:
            self._gpg = gpg

        # Instantiate the GPG binary to be used for key deletion: always delete keys without
        # invoking pinentry-mode=loopback
        # see: https://lists.gnupg.org/pipermail/gnupg-users/2016-May/055965.html
        self._gpg_for_key_deletion = gnupg.GPG(
            binary="gpg2", homedir=str(self._gpg_key_dir), options=["--yes", "--trust-model direct"]
        )

    @classmethod
    def get_default(cls) -> "EncryptionManager":
        global _default_encryption_mgr
        if _default_encryption_mgr is None:
            config = SecureDropConfig.get_current()
            _default_encryption_mgr = cls(
                gpg_key_dir=config.GPG_KEY_DIR,
            )
        return _default_encryption_mgr

    def get_journalist_public_key(self) -> str:
        return (self._gpg_key_dir / "journalist.pub").read_text()

    def encrypt_source_message(self, message_in: str, encrypted_message_path_out: Path) -> None:
        redwood.encrypt_message(
            recipients=[self.get_journalist_public_key()],
            plaintext=message_in,
            destination=encrypted_message_path_out,
        )

    def encrypt_source_file(self, filename: Path, encrypted_file_path_out: Path) -> None:
        redwood.encrypt_file(
            # A submission is only encrypted for the journalist key
            recipients=[self.get_journalist_public_key()],
            plaintext=filename,
            destination=encrypted_file_path_out,
        )

    def encrypt_journalist_reply(
        self, source: "Source", reply_in: str, encrypted_reply_path_out: Path
    ) -> None:
        redwood.encrypt_message(
            # A reply is encrypted for both the journalist key and the source key
            recipients=[source.public_key, self.get_journalist_public_key()],
            plaintext=reply_in,
            destination=encrypted_reply_path_out,
        )

    def decrypt_journalist_reply(
        self, source_user: "SourceUser", source: "Source", ciphertext_in: bytes
    ) -> str:
        return redwood.decrypt(
            ciphertext=ciphertext_in,
            secret_key=source.private_key,
            passphrase=source_user.gpg_secret,
        )
