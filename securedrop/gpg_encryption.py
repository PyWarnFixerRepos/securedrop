import os
import re
from distutils.version import StrictVersion
from pathlib import Path
from typing import Dict, Optional

import pretty_bad_protocol as gnupg


def _monkey_patch_username_in_env() -> None:
    # To fix https://github.com/freedomofpress/securedrop/issues/78
    os.environ["USERNAME"] = "www-data"


def _monkey_patch_unknown_status_message() -> None:
    # To fix https://github.com/isislovecruft/python-gnupg/issues/250 with Focal gnupg
    gnupg._parsers.Verify.TRUST_LEVELS["DECRYPTION_COMPLIANCE_MODE"] = 23


def _monkey_patch_delete_handle_status() -> None:
    # To fix https://github.com/freedomofpress/securedrop/issues/4294
    def _updated_handle_status(self: gnupg._parsers.DeleteResult, key: str, value: str) -> None:
        """
        Parse a status code from the attached GnuPG process.
        :raises: :exc:`~exceptions.ValueError` if the status message is unknown.
        """
        if key in ("DELETE_PROBLEM", "KEY_CONSIDERED"):
            self.status = self.problem_reason.get(value, "Unknown error: %r" % value)
        elif key in ("PINENTRY_LAUNCHED"):
            self.status = key.replace("_", " ").lower()
        else:
            raise ValueError("Unknown status message: %r" % key)

    gnupg._parsers.DeleteResult._handle_status = _updated_handle_status


def _setup_monkey_patches_for_gnupg() -> None:
    _monkey_patch_username_in_env()
    _monkey_patch_unknown_status_message()
    _monkey_patch_delete_handle_status()


_setup_monkey_patches_for_gnupg()


class GpgKeyNotFoundError(Exception):
    pass


class GpgEncryptError(Exception):
    pass


class GpgDecryptError(Exception):
    pass


_default_encryption_mgr: Optional["GpgEncryptionManager"] = None


class GpgEncryptionManager:
    """Legacy gpg-based EncryptionManager used for migrating to Sequoia"""

    SOURCE_KEY_NAME = "Source Key"
    SOURCE_KEY_UID_RE = re.compile(r"(Source|Autogenerated) Key <[-A-Za-z0-9+/=_]+>")

    def __init__(self, gpg_key_dir: Path, journalist_key_fingerprint: str) -> None:
        self.gpg_key_dir = gpg_key_dir
        self._journalist_key_fingerprint = journalist_key_fingerprint

        # Instantiate the "main" GPG binary
        gpg = gnupg.GPG(
            binary="gpg2", homedir=str(self.gpg_key_dir), options=["--trust-model direct"]
        )
        if StrictVersion(gpg.binary_version) >= StrictVersion("2.1"):
            # --pinentry-mode, required for SecureDrop on GPG 2.1.x+, was added in GPG 2.1.
            self._gpg = gnupg.GPG(
                binary="gpg2",
                homedir=str(gpg_key_dir),
                options=["--pinentry-mode loopback", "--trust-model direct"],
            )
        else:
            self._gpg = gpg

        # Instantiate the GPG binary to be used for key deletion: always delete keys without
        # invoking pinentry-mode=loopback
        # see: https://lists.gnupg.org/pipermail/gnupg-users/2016-May/055965.html
        self._gpg_for_key_deletion = gnupg.GPG(
            binary="gpg2", homedir=str(self.gpg_key_dir), options=["--yes", "--trust-model direct"]
        )

    @classmethod
    def get_default(cls) -> "GpgEncryptionManager":
        # Late import so the module can be used without a config.py in the parent folder
        from sdconfig import config

        global _default_encryption_mgr
        if _default_encryption_mgr is None:
            _default_encryption_mgr = cls(
                gpg_key_dir=Path(config.GPG_KEY_DIR),
                journalist_key_fingerprint=config.JOURNALIST_KEY,
            )
        return _default_encryption_mgr

    def delete_source_key_pair(self, source_filesystem_id: str) -> None:
        source_key_fingerprint = self.get_source_key_fingerprint(source_filesystem_id)

        # The subkeys keyword argument deletes both secret and public keys
        self._gpg_for_key_deletion.delete_keys(source_key_fingerprint, secret=True, subkeys=True)

    def get_journalist_public_key(self) -> str:
        return self._get_public_key(self._journalist_key_fingerprint)

    def get_source_public_key(
        self, source_filesystem_id: str, fingerprint: Optional[str] = None
    ) -> str:
        if fingerprint is None:
            fingerprint = self.get_source_key_fingerprint(source_filesystem_id)
        return self._get_public_key(fingerprint)

    def get_source_key_fingerprint(self, source_filesystem_id: str) -> str:
        source_key_details = self._get_source_key_details(source_filesystem_id)
        source_key_fingerprint = source_key_details["fingerprint"]
        return source_key_fingerprint

    def _get_source_key_details(self, source_filesystem_id: str) -> Dict[str, str]:
        for key in self._gpg.list_keys():
            for uid in key["uids"]:
                if source_filesystem_id in uid and self.SOURCE_KEY_UID_RE.match(uid):
                    return key
        raise GpgKeyNotFoundError()

    def _get_public_key(self, key_fingerprint: str) -> str:
        public_key = self._gpg.export_keys(key_fingerprint)
        if not public_key:
            raise GpgKeyNotFoundError()
        return public_key
